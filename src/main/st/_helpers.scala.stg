delimiters "$", "$"

cap(str) ::= <<$str; format="cap"$>>
decap(str) ::= <<$str; format="decap"$>>


// Class

wholeClassDef(base, mixin, body) ::= <<
$richClassDef(...)$

$concreteClassDef(base)$

$companionObjectDef(...)$
>>

extendClause(parent, mixin) ::= <%
$if(parent || mixin)$ extends $endif$
$if(parent)$Trait$parent; format="simple"$[V]$endif$
$if(parent && mixin)$ with $endif$
$mixin; separator=" with "$
%>

openRichClassDef(base, mixin, body) ::= <<$_openRichClassDef(base.simpleName, mixin, body)$>>
_openRichClassDef(name, mixin, body) ::= <<


class Rich$name$[V <: $name$](val basis: V) extends Trait$name$[V]
@inline implicit def $decap(name)$2Rich$name$[V <: $name$]($decap(name)$: V) = new Rich$name$[V]($decap(name)$)

trait Trait$name$[V <: $name$]$extendClause(base.parent, mixin)$ {

  $if(! base.parent)$def basis: V$endif$
>>

closeRichClassDef(base) ::= <<
  $properties(base)$
  $listeners(base)$
}
>>

richClassDef(base, mixin, body) ::= <<
$openRichClassDef(...)$
$closeRichClassDef(...)$
>>

withPrefix(name) ::= "S$name$"

openConcreteClassDef(base) ::= <<
$if(base.isA.View)$
$_openConcreteViewClassDef(base.simpleName, withPrefix(base.simpleName))$
$else$
$_openConcreteNonViewClassDef(base.simpleName, withPrefix(base.simpleName))$
$endif$
>>

_openConcreteViewClassDef(name, prefixedName) ::= <<
class $prefixedName$(implicit context: Context, parentVGroup: TraitViewGroup[_] = null)
    extends $name$(context) with Trait$name$[$prefixedName$] {
  def basis = this
  override val parentViewGroup = parentVGroup
>>

_openConcreteNonViewClassDef(name, prefixedName) ::= <<
class $prefixedName$(implicit context: Context)
    extends $name$(context) with Trait$name$[$prefixedName$] {
  def basis = this
>>

closeConcreteClassDef() ::= "}"

concreteClassDef(base) ::= <<
$openConcreteClassDef(base)$
$closeConcreteClassDef()$
>>


// companion object

companionObjectDef(base) ::= <<$_companionObjectDef(base, base.simpleName, withPrefix(base.simpleName))$>>
_companionObjectDef(base, name, prefixedName) ::= <<
object $prefixedName$ {

  $if(base.isA.View)$$viewConstructor(...)$$else$$nonViewConstructor(...)$
  $endif$

  $if(base.isA.TextView)$$textViewConstructor(...)$$endif$

  $if(base.isA.Button)$$buttonConstructors(...)$$endif$
}
>>

nonViewConstructor(base, name, prefixedName) ::= <<
def apply()(implicit context: Context): $prefixedName$ = new $prefixedName$
>>

viewConstructor(base, name, prefixedName) ::= <<
def apply[LP <: ViewGroupLayoutParams[_, $prefixedName$]]()
    (implicit context: Context, defaultLayoutParam: ($prefixedName$) => LP): $prefixedName$ = {
  val v = (new $prefixedName$)
  v.<<.parent.+=(v)
  v
}
>>

textViewConstructor(base, name, prefixedName) ::= <<
def apply[LP <: ViewGroupLayoutParams[_, $prefixedName$]](txt: CharSequence)
    (implicit context: Context, defaultLayoutParam: ($prefixedName$) => LP): $prefixedName$ =  {
  val v = (new $prefixedName$)
  v text txt
  v.<<.parent.+=(v)
  v
}  
>>

buttonConstructors(base, name, prefixedName) ::= <<
def apply[LP <: ViewGroupLayoutParams[_, $prefixedName$]](text: CharSequence, onClickListener: (View) => Unit)
    (implicit context: Context, defaultLayoutParam: ($prefixedName$) => LP): $prefixedName$ = {
  apply(text, func2ViewOnClickListener(onClickListener))
}

def apply[LP <: ViewGroupLayoutParams[_, $prefixedName$]](text: CharSequence, onClickListener: OnClickListener = {})
    (implicit context: Context, defaultLayoutParam: ($prefixedName$) => LP): $prefixedName$ = {
  val v = (new $prefixedName$)
  v.text = text
  v.setOnClickListener(onClickListener)
  v.<<.parent.+=(v)
  v
}
>>


// Listener

paramTypes(types) ::= <<($types; separator=", "$)>>

params(types) ::= <<$types:{ t | p$i$: $t$}; separator=", "$>>

callParams(types) ::= <<$types:{ t | p$i$}; separator=", "$>>

callbackBody(method, isUnit = false) ::= <%
$if(method.hasBody)$
  $if(isUnit)$
    f
  $else$
    f($callParams(method.paramTypes)$)
  $endif$
$endif$
%>

callbackMethod(method, isUnit = false) ::= <<
def $method.name$($params(method.paramTypes)$): $method.retType$ = { $callbackBody(...)$ }
>>

unitCallbackMethod(method) ::= <<$callbackMethod(method, true)$>>

fullListener(l) ::= <<
@inline def $l.name$(f: $paramTypes(l.paramTypes)$ => $l.retType$): V = {
  basis.$l.setter$(new $l.callbackClassName$ {
    $l.callbackMethods:callbackMethod(); separator="\n"$
  })
  basis
}
>>

unitListener(l) ::= <<
@inline def $l.name$(f: => $l.retType$): V = {
  basis.$l.setter$(new $l.callbackClassName$ {
    $l.callbackMethods:unitCallbackMethod(); separator="\n"$
  })
  basis
}
>>

listener(l) ::= <<
$if(l.hasParams)$$fullListener(l)$$endif$

$unitListener(l)$
>>

listeners(base) ::= <<$base.listeners:listener(); separator="\n\n"$>>


// property

getter(prop) ::= <<
$if(prop.getter)$
@inline def $prop.name$ = basis.$prop.getter.name$
$elseif( ! prop.nameClashes)$
@noEquivalentGetterExists
@inline def $prop.name$    : $prop.tpe$  = _defaultValue[$prop.tpe$]
$endif$
>>

setter(prop, method) ::= <<
@inline def $prop.name$  (p: $method.paramTypes$) =            $prop.name$_=  (p)
@inline def $prop.name$_=(p: $method.paramTypes$) = { basis.$method.name$    (p); basis }
>>

switch(name, setter) ::= <<
@inline def  enable$name$               = { basis.$setter.name$(true ); basis }
@inline def disable$name$               = { basis.$setter.name$(false); basis }
>>

setters(prop) ::= <<
$prop.setters:{ s | $setter(prop, s)$}; separator="\n"$
$if(prop.switch)$
$switch(prop.switch, first(prop.setters))$
$endif$
>>

property(prop) ::= <<$getter(prop)$$setters(prop)$>>

properties(base) ::= <<$base.properties:property()$>>


// service

systemServiceHead(base) ::= <<
@inline def $decap(base.simpleName)$ (implicit context: Context): $base.simpleName$ =
  context.getSystemService(Context.$base.simpleName; format="manager-to-service"$).asInstanceOf[$base.simpleName$]
>>


// etc

license() ::= <<
/* 
 *
 * 
 *
 *
 * Less painful Android development with Scala
 *
 * http://scaloid.org
 *
 *
 *
 *
 *
 *
 * Copyright 2013 Sung-Ho Lee
 *
 * Sung-Ho Lee licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */

/*
 * This file is automatically generated. Any changes on this file will be overwritten!
 */ 

>>
